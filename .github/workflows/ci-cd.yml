name: Flask CI/CD Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  lint:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install flake8
        run: pip install flake8
        
      - name: Run lint (non-blocking)
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || echo "Lint warnings found, but continuing..."
        continue-on-error: true

  sast:
    runs-on: self-hosted
    needs: lint
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install Bandit
        run: pip install bandit
        
      - name: Run SAST
        run: bandit -r . -f json -o bandit-report.json || echo "SAST scan completed with warnings"
        continue-on-error: true

  unit-test:
    runs-on: self-hosted
    needs: lint
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Create requirements.txt if not exists
        run: |
          if [ ! -f requirements.txt ]; then
            echo "Flask==2.3.3" > requirements.txt
          fi
          
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest
          
      - name: Create basic test if not exists
        run: |
          if [ ! -f test_app.py ]; then
            cat > test_app.py << 'EOF'
          import pytest
          from app import app
          
          @pytest.fixture
          def client():
              app.config['TESTING'] = True
              with app.test_client() as client:
                  yield client
          
          def test_hello(client):
              rv = client.get('/')
              assert b'Hello from a CI/CD Pipeline!' in rv.data
          EOF
          fi
          
      - name: Run tests
        run: pytest -v || echo "Tests completed"

  sca:
    runs-on: self-hosted
    needs: [sast, unit-test]
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          ignore-unfixed: true
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

  docker:
    runs-on: self-hosted
    needs: [sast, unit-test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Start Docker service
        run: |
          echo "Checking Docker service status..."
          sudo systemctl status docker || {
            echo "Starting Docker service..."
            sudo systemctl start docker
            sleep 5
            sudo systemctl status docker
          }
          
      - name: Add runner user to docker group
        run: |
          echo "Adding user to docker group..."
          sudo usermod -aG docker $USER || echo "User might already be in docker group"
          echo "Current groups: $(groups)"
          
      - name: Test Docker access
        run: |
          echo "Testing Docker access..."
          # Use newgrp to apply group changes in current session
          newgrp docker << EONG
          docker info || {
            echo "Docker access failed, trying with sudo..."
            sudo docker info
          }
          EONG
        
      - name: Create Dockerfile if needed
        run: |
          if [ ! -f Dockerfile ]; then
            echo "Creating Dockerfile..."
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim
          
          WORKDIR /app
          
          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt
          
          COPY . .
          
          EXPOSE 80
          
          CMD ["python", "app.py"]
          EOF
          else
            echo "Dockerfile already exists"
            cat Dockerfile
          fi
          
      - name: Build Docker image
        run: |
          echo "Building Docker image..."
          # Try without sudo first, then with sudo if needed
          docker build -t flask-app:${{ github.sha }} . || {
            echo "Docker build failed, trying with sudo..."
            sudo docker build -t flask-app:${{ github.sha }} .
          }
          
      - name: Push Docker image (if configured)
        run: |
          if [ ! -z "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ ! -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "Logging into Docker Hub..."
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
            
            echo "Tagging and pushing image..."
            docker tag flask-app:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }}
            docker tag flask-app:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:latest
            
            echo "Pushing image with SHA tag..."
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }}
            
            echo "Pushing image with latest tag..."
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:latest
            
            echo "Verifying pushed images..."
            docker pull ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }} || {
              echo "ERROR: Failed to verify pushed image"
              exit 1
            }
            
            echo "Docker image pushed and verified successfully"
          else
            echo "Docker Hub credentials not configured, skipping push"
            echo "Will use local image for deployment"
          fi
        continue-on-error: true

  deploy:
    runs-on: self-hosted
    needs: docker
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check kubectl installation
        run: |
          kubectl version --client || {
            echo "kubectl not found, installing..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          }
          
      - name: Verify Kubernetes connection
        run: |
          kubectl cluster-info || {
            echo "Cannot connect to Kubernetes cluster"
            echo "Please ensure kubeconfig is properly configured"
            exit 1
          }
        continue-on-error: true
        
      - name: Create Docker Hub secret for Kubernetes
        run: |
          if [ ! -z "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ ! -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "Creating Docker Hub secret for Kubernetes..."
            kubectl create secret docker-registry dockerhub-secret \
              --docker-server=https://index.docker.io/v1/ \
              --docker-username=${{ secrets.DOCKERHUB_USERNAME }} \
              --docker-password=${{ secrets.DOCKERHUB_TOKEN }} \
              --docker-email=your-email@example.com \
              --dry-run=client -o yaml | kubectl apply -f -
            echo "Docker Hub secret created/updated"
          else
            echo "No Docker Hub credentials, skipping secret creation"
          fi
        continue-on-error: true
        
      - name: Deploy to Kubernetes
        run: |
          # Replace placeholders in deployment.yaml
          if [ ! -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
            IMAGE_TAG="${{ github.sha }}"
            echo "Using Docker Hub image: $DOCKERHUB_USERNAME/flask-app:$IMAGE_TAG"
          else
            echo "No Docker Hub credentials, using local image"
            DOCKERHUB_USERNAME="flask-app"
            IMAGE_TAG="${{ github.sha }}"
            echo "Using local image: $DOCKERHUB_USERNAME:$IMAGE_TAG"
          fi
          
          # Update deployment.yaml with actual values
          sed "s/\${DOCKERHUB_USERNAME}/$DOCKERHUB_USERNAME/g; s/\${IMAGE_TAG}/$IMAGE_TAG/g" deployment.yaml > deployment-updated.yaml
          
          echo "=== Generated deployment.yaml ==="
          cat deployment-updated.yaml
          echo "================================="
          
          echo "Applying Kubernetes deployment..."
          kubectl apply -f deployment-updated.yaml
          
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/flask-app --timeout=600s || {
            echo "Deployment failed or timed out"
            echo ""
            echo "=== Deployment Description ==="
            kubectl describe deployment flask-app
            echo ""
            echo "=== Pod Status ==="
            kubectl get pods -l app=flask-app -o wide
            echo ""
            echo "=== Pod Logs ==="
            for pod in $(kubectl get pods -l app=flask-app -o name); do
              echo "--- Logs for $pod ---"
              kubectl logs $pod --tail=50 || echo "Could not get logs for $pod"
              echo ""
              echo "--- Events for $pod ---"
              kubectl describe $pod | grep -A 20 "Events:" || echo "No events found"
              echo ""
            done
            exit 1
          }
          
      - name: Get service information
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments flask-app
          echo ""
          echo "=== Pods ==="
          kubectl get pods -l app=flask-app
          echo ""
          echo "=== Service ==="
          kubectl get service flask-service
          echo ""
          echo "=== Service URL ==="
          NODE_PORT=$(kubectl get service flask-service -o jsonpath='{.spec.ports[0].nodePort}')
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
          if [ -z "$NODE_IP" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          fi
          echo "Application should be accessible at: http://$NODE_IP:$NODE_PORT"
        continue-on-error: true

  dast:
    runs-on: self-hosted
    needs: deploy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Get application URL
        id: get_url
        run: |
          echo "Getting application URL..."
          NODE_PORT=$(kubectl get service flask-service -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
          if [ -z "$NODE_IP" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null || echo "localhost")
          fi
          APP_URL="http://$NODE_IP:$NODE_PORT"
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Application URL: $APP_URL"
          
      - name: Wait for application to be ready
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Waiting for application to be ready at $APP_URL"
          
          for i in {1..30}; do
            if curl -f "$APP_URL" >/dev/null 2>&1; then
              echo "Application is ready!"
              break
            fi
            echo "Attempt $i: Application not ready yet, waiting..."
            sleep 10
          done
          
          # Final check
          curl -f "$APP_URL" || {
            echo "Application is not responding after 5 minutes"
            echo "Continuing with DAST scan anyway..."
          }
        continue-on-error: true
        
      - name: Install OWASP ZAP
        run: |
          if ! command -v zap-baseline.py &> /dev/null; then
            echo "Installing OWASP ZAP..."
            
            # Install Java (required for ZAP)
            sudo apt update
            sudo apt install -y openjdk-11-jdk wget
            
            # Download and install ZAP
            wget -q https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_unix.sh -O zap_installer.sh
            chmod +x zap_installer.sh
            echo "y" | sudo ./zap_installer.sh -q
            
            # Add ZAP to PATH
            echo 'export PATH=$PATH:/opt/zaproxy' >> ~/.bashrc
            export PATH=$PATH:/opt/zaproxy
          else
            echo "OWASP ZAP already installed"
          fi
          
      - name: Run OWASP ZAP Baseline Scan
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Running DAST scan on: $APP_URL"
          
          # Create ZAP reports directory
          mkdir -p zap-reports
          
          # Run ZAP baseline scan
          export PATH=$PATH:/opt/zaproxy
          
          /opt/zaproxy/zap-baseline.py \
            -t "$APP_URL" \
            -J zap-reports/zap-baseline-report.json \
            -H zap-reports/zap-baseline-report.html \
            -r zap-reports/zap-baseline-report.md \
            --autooff \
            -I || {
              echo "DAST scan completed with findings"
              echo "Check the reports for security issues"
            }
          
          echo "DAST scan completed. Reports generated in zap-reports/"
          
          # Show summary if available
          if [ -f zap-reports/zap-baseline-report.md ]; then
            echo "=== DAST Scan Summary ==="
            head -20 zap-reports/zap-baseline-report.md
          fi
        continue-on-error: true
        
      - name: Upload DAST Reports
        run: |
          echo "DAST scan artifacts created:"
          ls -la zap-reports/ || echo "No reports directory found"
        continue-on-error: true

  security-test:
    runs-on: self-hosted
    needs: docker
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy security scan on built image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'flask-app:${{ github.sha }}'
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
        continue-on-error: true

  
