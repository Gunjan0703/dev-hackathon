name: Flask CI/CD Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  lint:
    runs-on: self-hosted
    steps:
      - name: Debug - Check environment
        run: |
          echo "=== Environment Check ==="
          whoami
          pwd
          python3 --version || echo "Python3 not found"
          pip3 --version || echo "Pip3 not found"
          docker --version || echo "Docker not found"
          echo "=== End Environment Check ==="
          
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install flake8
        run: |
          echo "Installing flake8..."
          pip3 install flake8 || python3 -m pip install flake8
          
      - name: Run lint
        run: |
          echo "Running flake8 lint check..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || echo "Lint warnings found, but continuing..."
        continue-on-error: true

  sast:
    runs-on: self-hosted
    needs: lint
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install Bandit
        run: pip install bandit
        
      - name: Run SAST
        run: bandit -r . -f json -o bandit-report.json || echo "SAST scan completed with warnings"
        continue-on-error: true

  unit-test:
    runs-on: self-hosted
    needs: lint
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Create requirements.txt if not exists
        run: |
          if [ ! -f requirements.txt ]; then
            echo "Flask==2.3.3" > requirements.txt
          fi
          
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest
          
      - name: Create basic test if not exists
        run: |
          if [ ! -f test_app.py ]; then
            cat > test_app.py << 'EOF'
          import pytest
          from app import app
          
          @pytest.fixture
          def client():
              app.config['TESTING'] = True
              with app.test_client() as client:
                  yield client
          
          def test_hello(client):
              rv = client.get('/')
              assert b'Hello from a CI/CD Pipeline!' in rv.data
          EOF
          fi
          
      - name: Run tests
        run: pytest -v || echo "Tests completed"

  sca:
    runs-on: self-hosted
    needs: [sast, unit-test]
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          ignore-unfixed: true
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

  docker:
    runs-on: self-hosted
    needs: [sca]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Start Docker service
        run: |
          echo "Checking Docker service status..."
          sudo systemctl status docker || {
            echo "Starting Docker service..."
            sudo systemctl start docker
            sleep 5
            sudo systemctl status docker
          }
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          
      - name: Add runner user to docker group
        run: |
          echo "Adding user to docker group..."
          sudo usermod -aG docker $USER || echo "User might already be in docker group"
          echo "Current groups: $(groups)"
          
      - name: Test Docker access
        run: |
          echo "Testing Docker access..."
          # Use newgrp to apply group changes in current session
          newgrp docker << EONG
          docker info || {
            echo "Docker access failed, trying with sudo..."
            sudo docker info
          }
          EONG
          
      - name: Create Dockerfile if needed
        run: |
          if [ ! -f Dockerfile ]; then
            echo "Creating Dockerfile..."
            cat > Dockerfile << 'EOF'
          FROM python:3.9-slim
          
          WORKDIR /app
          
          COPY requirements.txt .
          RUN pip install --no-cache-dir -r requirements.txt
          
          COPY . .
          
          EXPOSE 80
          
          CMD ["python", "app.py"]
          EOF
          else
            echo "Dockerfile already exists"
            cat Dockerfile
          fi
          
      - name: Ensure requirements.txt exists
        run: |
          if [ ! -f requirements.txt ]; then
            echo "Flask==2.3.3" > requirements.txt
          fi
          
      - name: Build Docker image
        run: |
          echo "Building Docker image..."
          # Try without sudo first, then with sudo if needed
          docker build -t flask-app:${{ github.sha }} . || {
            echo "Docker build failed, trying with sudo..."
            sudo docker build -t flask-app:${{ github.sha }} .
          }
          
      - name: Push Docker image (force push)
        run: |
          if [ ! -z "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ ! -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "Force pushing Docker image..."
            
            # Ensure we're logged in
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
            
            # Re-tag and push
            docker tag flask-app:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }}
            docker tag flask-app:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:latest
            
            echo "Pushing SHA-tagged image..."
            
            docker tag flask-app:${{ github.sha }} ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:latest

            docker push ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }}
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:latest

            
            echo "Pushing latest image..."
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:latest
            
            echo "Verifying image exists on Docker Hub..."
            sleep 10  # Wait for Docker Hub to process
            docker manifest inspect ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }} || {
              echo "ERROR: Image still not found on Docker Hub after push!"
              echo "Checking Docker Hub repository settings..."
              exit 1
            }
            
            echo "âœ… Docker image successfully pushed and verified!"
          else
            echo "âŒ Docker Hub credentials not configured"
            echo "Deployment will use local image"
          fi
        continue-on-error: true

  deploy:
    runs-on: self-hosted
    needs: docker
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check kubectl installation
        run: |
          kubectl version --client || {
            echo "kubectl not found, installing..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          }
          
      - name: Verify Kubernetes connection
        run: |
          kubectl cluster-info || {
            echo "Cannot connect to Kubernetes cluster"
            echo "Please ensure kubeconfig is properly configured"
            exit 1
          }
        continue-on-error: true
        
      - name: Create Docker Hub secret for Kubernetes
        run: |
          if [ ! -z "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ ! -z "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "Creating Docker Hub secret for Kubernetes..."
            kubectl create secret docker-registry dockerhub-secret \
              --docker-server=https://index.docker.io/v1/ \
              --docker-username=${{ secrets.DOCKERHUB_USERNAME }} \
              --docker-password=${{ secrets.DOCKERHUB_TOKEN }} \
              --docker-email=your-email@example.com \
              --dry-run=client -o yaml | kubectl apply -f -
            echo "Docker Hub secret created/updated"
          else
            echo "No Docker Hub credentials, skipping secret creation"
          fi
        continue-on-error: true
        
      - name: Deploy to Kubernetes
        run: |
          # Check if we have Docker Hub credentials and image was pushed
          if [ ! -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            echo "Checking if Docker Hub image is available..."
            if docker manifest inspect ${{ secrets.DOCKERHUB_USERNAME }}/flask-app:${{ github.sha }} >/dev/null 2>&1; then
              DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
              IMAGE_TAG="${{ github.sha }}"
              echo "âœ… Using Docker Hub image: $DOCKERHUB_USERNAME/flask-app:$IMAGE_TAG"
            else
              echo "âŒ Docker Hub image not available, falling back to local image"
              DOCKERHUB_USERNAME="flask-app"
              IMAGE_TAG="${{ github.sha }}"
              echo "ðŸ”„ Using local image: $DOCKERHUB_USERNAME:$IMAGE_TAG"
              
              # Remove imagePullSecrets from deployment since we're using local image
              sed -i '/imagePullSecrets:/,+1d' deployment.yaml
            fi
          else
            echo "No Docker Hub credentials, using local image"
            DOCKERHUB_USERNAME="flask-app" 
            IMAGE_TAG="${{ github.sha }}"
            echo "Using local image: $DOCKERHUB_USERNAME:$IMAGE_TAG"
            
            # Remove imagePullSecrets from deployment
            sed -i '/imagePullSecrets:/,+1d' deployment.yaml
          fi
          
          # Update deployment.yaml with actual values
          if [ "$DOCKERHUB_USERNAME" = "flask-app" ]; then
            # For local image, use different format
            sed "s|\${DOCKERHUB_USERNAME}/flask-app:\${IMAGE_TAG}|$DOCKERHUB_USERNAME:$IMAGE_TAG|g" deployment.yaml > deployment-updated.yaml
          else
            # For Docker Hub image, use normal format
            sed "s/\${DOCKERHUB_USERNAME}/$DOCKERHUB_USERNAME/g; s/\${IMAGE_TAG}/$IMAGE_TAG/g" deployment.yaml > deployment-updated.yaml
          fi
          
          echo "=== Generated deployment.yaml ==="
          cat deployment-updated.yaml
          echo "================================="
          
          echo "Applying Kubernetes deployment..."
          kubectl apply -f deployment-updated.yaml
          
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/flask-app --timeout=600s || {
            echo "Deployment failed or timed out"
            echo ""
            echo "=== Deployment Description ==="
            kubectl describe deployment flask-app
            echo ""
            echo "=== Pod Status ==="
            kubectl get pods -l app=flask-app -o wide
            echo ""
            echo "=== Pod Details ==="
            for pod in $(kubectl get pods -l app=flask-app -o name); do
              echo "--- Details for $pod ---"
              kubectl describe $pod
              echo ""
            done
            exit 1
          }
          
      - name: Get service information
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments flask-app
          echo ""
          echo "=== Pods ==="
          kubectl get pods -l app=flask-app
          echo ""
          echo "=== Service ==="
          kubectl get service flask-service
          echo ""
          echo "=== Service URL ==="
          NODE_PORT=$(kubectl get service flask-service -o jsonpath='{.spec.ports[0].nodePort}')
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
          if [ -z "$NODE_IP" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          fi
          echo "Application should be accessible at: http://$NODE_IP:$NODE_PORT"
        continue-on-error: true

  dast:
    runs-on: self-hosted
    needs: deploy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Get application URL
        id: get_url
        run: |
          echo "Getting application URL..."
          NODE_PORT=$(kubectl get service flask-service -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "30080")
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}' 2>/dev/null)
          if [ -z "$NODE_IP" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}' 2>/dev/null || echo "localhost")
          fi
          APP_URL="http://$NODE_IP:$NODE_PORT"
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "Application URL: $APP_URL"
          
      - name: Wait for application to be ready
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Waiting for application to be ready at $APP_URL"
          
          for i in {1..30}; do
            if curl -f "$APP_URL" >/dev/null 2>&1; then
              echo "Application is ready!"
              break
            fi
            echo "Attempt $i: Application not ready yet, waiting..."
            sleep 10
          done
          
          # Final check
          curl -f "$APP_URL" || {
            echo "Application is not responding after 5 minutes"
            echo "Continuing with DAST scan anyway..."
          }
        continue-on-error: true
        
      - name: Install OWASP ZAP
        run: |
          if ! command -v zap-baseline.py &> /dev/null; then
            echo "Installing OWASP ZAP..."
            
            # Install Java (required for ZAP)
            sudo apt update
            sudo apt install -y openjdk-11-jdk wget
            
            # Download and install ZAP
            wget -q https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_unix.sh -O zap_installer.sh
            chmod +x zap_installer.sh
            echo "y" | sudo ./zap_installer.sh -q
            
            # Add ZAP to PATH
            echo 'export PATH=$PATH:/opt/zaproxy' >> ~/.bashrc
            export PATH=$PATH:/opt/zaproxy
          else
            echo "OWASP ZAP already installed"
          fi
          
      - name: Run OWASP ZAP Baseline Scan
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Running DAST scan on: $APP_URL"
          
          # Create ZAP reports directory
          mkdir -p zap-reports
          
          # Run ZAP baseline scan
          export PATH=$PATH:/opt/zaproxy
          
          /opt/zaproxy/zap-baseline.py \
            -t "$APP_URL" \
            -J zap-reports/zap-baseline-report.json \
            -H zap-reports/zap-baseline-report.html \
            -r zap-reports/zap-baseline-report.md \
            --autooff \
            -I || {
              echo "DAST scan completed with findings"
              echo "Check the reports for security issues"
            }
          
          echo "DAST scan completed. Reports generated in zap-reports/"
          
          # Show summary if available
          if [ -f zap-reports/zap-baseline-report.md ]; then
            echo "=== DAST Scan Summary ==="
            head -20 zap-reports/zap-baseline-report.md
          fi
        continue-on-error: true
        
      - name: Upload DAST Reports
        run: |
          echo "DAST scan artifacts created:"
          ls -la zap-reports/ || echo "No reports directory found"
        continue-on-error: true
  security-test:
    runs-on: self-hosted
    needs: docker
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy security scan on built image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'flask-app:${{ github.sha }}'
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
        continue-on-error: true

  
